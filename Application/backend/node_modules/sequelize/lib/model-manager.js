"use strict";
const Toposort = require("toposort");
const _ = require("lodash");
class ModelManager {
  constructor(sequelize) {
    this.models = [];
    this.sequelize = sequelize;
  }
  addModel(model) {
    this.models.push(model);
    this.sequelize.models[model.name] = model;
    return model;
  }
  removeModel(modelToRemove) {
    this.models = this.models.filter((model) => model.name !== modelToRemove.name);
    delete this.sequelize.models[modelToRemove.name];
  }
  getModel(against, options) {
    options = _.defaults(options || {}, {
      attribute: "name"
    });
    return this.models.find((model) => model[options.attribute] === against);
  }
  findModel(callback) {
    return this.models.find(callback);
  }
  get all() {
    return this.models;
  }
  getModelsTopoSortedByForeignKey() {
    const models = /* @__PURE__ */ new Map();
    const edges = [];
    const nameToModel = new Map();
    
    for (const model of this.models) {
      let tableName = model.getTableName();
      if (_.isObject(tableName)) {
        tableName = `${tableName.schema}.${tableName.tableName}`;
      }
      
      models.set(tableName, model);
      nameToModel.set(tableName, model);
      
      for (const attrName in model.rawAttributes) {
        if (Object.prototype.hasOwnProperty.call(model.rawAttributes, attrName)) {
          const attribute = model.rawAttributes[attrName];
          if (attribute.references) {
            let dep = attribute.references.model;
            if (_.isObject(dep)) {
              dep = `${dep.schema}.${dep.tableName}`;
            }
            
            if (tableName !== dep) {
              edges.push([dep, tableName]);
            }
          }
        }
      }
    }
    
    let sorted;
    try {
      sorted = Toposort(edges);
    } catch (e) {
      return null;
    }
    
    return sorted
      .filter(tableName => nameToModel.has(tableName))
      .map(tableName => nameToModel.get(tableName));
  }
  forEachModel(iterator, options) {
    const sortedModels = this.getModelsTopoSortedByForeignKey();
    if (sortedModels == null) {
      throw new Error("Cyclic dependency found.");
    }
    options = _.defaults(options || {}, {
      reverse: true
    });
    if (options.reverse) {
      sortedModels.reverse();
    }
    for (const model of sortedModels) {
      iterator(model);
    }
  }
}
module.exports = ModelManager;
module.exports.ModelManager = ModelManager;
module.exports.default = ModelManager;
//# sourceMappingURL=model-manager.js.map
